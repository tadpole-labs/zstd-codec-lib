function t(t){const i=t instanceof Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):void 0,s=new n({...e.bufSizes,dictionary:i});return s.init(c),s}function i(t,i){if(1===t.length)return t[0];const s=new Uint8Array(i);for(let i=0,r=0;t.length>i;++i){const n=t[i];s.set(n,r),r+=n.length}return s}async function s(i=0,s){if(!c){const t=e.t();c=t instanceof Promise?await t:t}h.has(i)||(h.set(i,new Map),a.set(i,[]));const r=h.get(i),n=a.get(i);for(let t=0;n.length>t;t++)if(!n[t])return n[t]=!0,[r.get(t),t,i];const o=s?.dictionary||f.get(i),w=t(i>0?o:void 0);if(n.length>=2)return[w,-1,i];const u=n.length;return r.set(u,w),n.push(!0),[w,u,i]}function r(t,i){const s=a.get(i);s&&(s[t]=!1)}var n,e,h,a,o,c,f,w,u,d,m,l,y,_=Error,p=(t,i,s)=>{let r=0,n=0;for(;s>r;++r)n|=t[i++]<<(r<<3);return n},S=t=>{if(3126568==(t[0]|t[1]<<8|t[2]<<16)&&253==t[3]){const i=t[4],s=i>>5&1,r=3&i,n=i>>6;if(8&i)throw new _("invalid zstd data");let e=6-s;const h=3==r?4:r,a=p(t,e,h),o=p(t,e+h,n?1<<n:s)+(1==n&&256);let c=o;if(!s){const i=1<<10+(t[5]>>3);c=i+(i>>3)*(7&t[5])}if(c>2145386496)throw new _("win size 2 large");return{d:a,e:c,u:o}}throw new _("invalid zstd data")},b=9830464,z=2097152,A={buf:new Uint8Array(0),in_offset:0};n=class{i;h;o;m;l;_;p=0;S=0;A=0;U=0;M=0;P=b;constructor(t={}){this._={dictionary:t.dictionary,maxSrcSize:Math.max(t.maxSrcSize||0,629149696),maxDstSize:Math.max(t.maxDstSize||0,629149696)}}init(t){return this.i=new WebAssembly.Instance(t,{env:{}}),this.v()}D(t,i){return this.i=t,this.v()}v(){if(this.h=this.i.exports,this.o=this.i.exports.memory,this.m=new Uint8Array(this.o.buffer),this.l=new Uint32Array(this.o.buffer),this.p=8196,this.S=this.p+12,this.h.createDCtx(),this._.dictionary){const t=this._.dictionary.length;if(t>4194304)throw new _("dict>2mb max size");const i=this.$(t);this.m.set(this._.dictionary,i),this.A=this.h.createDict(i,t)}return this.U=this.$(z),this.M=this.U+z,this}$(t){return this.h.malloc(t)}decompressSync(t,i){if(!this.h)throw new _("not initialized");const s=t.length;if(s>this._.maxSrcSize)throw new _(`comp data ${s}b>maxSrcSize lim ${this._.maxSrcSize}b)`);if(i||(i=(t=>{const i=t[4],s=i>>5&1,r=3&i,n=i>>6;return p(t,6-s+r==3?4:r,n?1<<n:s)+(1==n&&256)})(t)),!i||i>b||s>z)return this.decompressStream(t,!0).buf;this.m.set(t,this.U),this.h.prune_buf(this.M);const r=this.M,n=this.h.decompressSync(r,this.P,this.U,s,this.A);if(0>n)throw new _("decomp err "+n);return this.m.slice(r,r+n)}W(t,i,s){const r=t>>>2;this.l[r]=i,this.l[r+1]=s,this.l[r+2]=0}B(t){return this.l[t+8>>>2]}decompressStream(t,s=!1){if(!this.h)throw new _("not initialized");if(s&&(this.h.reset(),this.A&&this.h.refDict(this.A),this.h.prune_buf(this.M)),!t||0===t.length)return A;const r=[];let n=0,e=0;const h=this.U+262150;let a=h,o=h+655360,c=0;for(;t.length>e;){const i=Math.min(Math.min(t.length-e,131075),262150);for(this.m.set(t.subarray(e,e+i),this.U),this.W(this.p,this.U,i),a==h&&this.W(this.S,a,917501);this.B(this.p)<i;){const t=this.h.decStream();if(0>t)throw new _("decomp err "+t);const i=this.B(this.S);if(n+=a==h?i:i-c,c=i,i>0&&(a=h+i,o>a||(r.push(this.m.slice(h,a)),a=h,this.W(this.S,a,917501)),n>this._.maxDstSize))throw new _(`decomp size ${n}b>maxDstSize lim ${this._.maxDstSize}b`)}e+=i}return a!=h&&r.push(this.m.slice(h,a)),{buf:i(r,n),in_offset:t.length}}destroy(){this.A=this.U=this.M=this.p=this.S=this.i=this.h=this.o=this.m=this.l=null}},e={t:null,bufSizes:{maxSrcSize:0,maxDstSize:0},dictionaries:[]},h=new Map,a=new Map,o=!1,f=new Map,w=t=>{if(6>t.length)return 0;try{const i=S(t),s="object"==typeof i?i.d:0;return s>0&&f.set(s,t),s}catch{return 0}},u=async(i={})=>(o||(c=await e.t(i.wasmPath),o=!0),t(i.dictionary)),d=t=>t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t);class U{readable;writable;constructor(t){let n,e=-1,h=0,a=!0,o=[],c={d:0,u:0,e:-1},f=0,u=0,m=0,y=262144;const{readable:p,writable:b}=new TransformStream({async transform(i,r){const l=d(i);if(f+=l.length,o.push(l),m++,f>=12){if(-1==c.e){const t=new Uint8Array(f);let i=0;for(let s=0;m>s;s++)t.set(o[s],i),i+=o[s].length;c=S(t),y=Math.max(y,c.e,Math.max(c.u>>4,1<<17))}if(f>=y&&-1!=c.e){if(n){const t=n.decompressStream(l,!1).buf;return void(t.length>0&&r.enqueue(t))}try{a&&(h=w(l),[n,e,h]=await s(h,t));const i=n.decompressStream(l,a).buf;u+=i.length,r.enqueue(i),a=!1}catch(t){r.error(new _("decomp err "+t))}}}},async flush(s){if(0==u&&f>6)try{const r=await l(i(o,f),!0,t);s.enqueue(r.buf)}catch(t){s.error(new _("decomp err "+t))}else-1==e?n?.destroy():r(e,h);s.terminate()}});this.readable=p,this.writable=b}}m=async(t,i)=>(await l(t,!0,i)).buf,l=async(t,i=!1,n)=>{const e=w(t),[h,a]=await s(e,n),o=h.decompressStream(t,i);return-1===a?h.destroy():r(a,e),o},y=async(t,i,n)=>{const e=w(t),[h,a]=await s(e,n),o=h.decompressSync(t,i);return-1===a?h.destroy():r(a,e),o},e.t=async t=>{const i=t||new URL("./zstd-decoder.wasm",import.meta.url).href,s=await fetch(i);return await WebAssembly.compileStreaming(s)};export{y as decompressSync,l as decompressStream,m as decompress,u as createDecoder,U as ZstdDecompressionStream,n as ZstdDecoder};