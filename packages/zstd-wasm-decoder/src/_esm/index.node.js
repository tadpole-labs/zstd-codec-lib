function t(t){const i=t instanceof Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):void 0,s=new n({...e.bufSizes,dictionary:i});return s.init(c),s}function i(t,i){if(1===t.length)return t[0];const s=new Uint8Array(i);for(let i=0,r=0;t.length>i;++i){const n=t[i];s.set(n,r),r+=n.length}return s}async function s(i=0,s){if(!c){const t=e.t();c=t instanceof Promise?await t:t}h.has(i)||(h.set(i,new Map),o.set(i,[]));const r=h.get(i),n=o.get(i);for(let t=0;n.length>t;t++)if(!n[t])return n[t]=!0,[r.get(t),t,i];const a=s?.dictionary||f.get(i),w=t(i>0?a:void 0);if(n.length>=2)return[w,-1,i];const u=n.length;return r.set(u,w),n.push(!0),[w,u,i]}function r(t,i){const s=o.get(i);s&&(s[t]=!1)}var n,e,h,o,a,c,f,w,u,m,d,l,y,p=Error,_=(t,i,s)=>{let r=0,n=0;for(;s>r;++r)n|=t[i++]<<(r<<3);return n},S=t=>{if(3126568==(t[0]|t[1]<<8|t[2]<<16)&&253==t[3]){const i=t[4],s=i>>5&1,r=3&i,n=i>>6;if(8&i)throw new p("invalid zstd data");let e=6-s;const h=3==r?4:r,o=_(t,e,h),a=_(t,e+h,n?1<<n:s)+(1==n&&256);let c=a;if(!s){const i=1<<10+(t[5]>>3);c=i+(i>>3)*(7&t[5])}if(c>2145386496)throw new p("win size 2 large");return{d:o,e:c,u:a}}throw new p("invalid zstd data")},b=9830464,z=2097152,A={buf:new Uint8Array(0),in_offset:0};n=class{i;h;o;m;l;p;_=0;S=0;A=0;U=0;M=0;P=b;constructor(t={}){this.p={dictionary:t.dictionary,maxSrcSize:Math.max(t.maxSrcSize||0,629149696),maxDstSize:Math.max(t.maxDstSize||0,629149696)}}init(t){return this.i=new WebAssembly.Instance(t,{env:{}}),this.v()}D(t,i){return this.i=t,this.v()}v(){if(this.h=this.i.exports,this.o=this.i.exports.memory,this.m=new Uint8Array(this.o.buffer),this.l=new Uint32Array(this.o.buffer),this._=8196,this.S=this._+12,this.h.createDCtx(),this.p.dictionary){const t=this.p.dictionary.length;if(t>4194304)throw new p("dict>2mb max size");const i=this.$(t);this.m.set(this.p.dictionary,i),this.A=this.h.createDict(i,t)}return this.U=this.$(z),this.M=this.U+z,this}$(t){return this.h.malloc(t)}decompressSync(t,i){if(!this.h)throw new p("not initialized");const s=t.length;if(s>this.p.maxSrcSize)throw new p(`comp data ${s}b>maxSrcSize lim ${this.p.maxSrcSize}b)`);if(i||(i=(t=>{const i=t[4],s=i>>5&1,r=3&i,n=i>>6;return _(t,6-s+r==3?4:r,n?1<<n:s)+(1==n&&256)})(t)),!i||i>b||s>z)return this.decompressStream(t,!0).buf;this.m.set(t,this.U),this.h.prune_buf(this.M);const r=this.M,n=this.h.decompressSync(r,this.P,this.U,s,this.A);if(0>n)throw new p("decomp err "+n);return this.m.slice(r,r+n)}W(t,i,s){const r=t>>>2;this.l[r]=i,this.l[r+1]=s,this.l[r+2]=0}B(t){return this.l[t+8>>>2]}decompressStream(t,s=!1){if(!this.h)throw new p("not initialized");if(s&&(this.h.reset(),this.A&&this.h.refDict(this.A),this.h.prune_buf(this.M)),!t||0===t.length)return A;const r=[];let n=0,e=0;const h=this.U+262150;let o=h,a=h+655360,c=0;for(;t.length>e;){const i=Math.min(Math.min(t.length-e,131075),262150);for(this.m.set(t.subarray(e,e+i),this.U),this.W(this._,this.U,i),o==h&&this.W(this.S,o,917501);this.B(this._)<i;){const t=this.h.decStream();if(0>t)throw new p("decomp err "+t);const i=this.B(this.S);if(n+=o==h?i:i-c,c=i,i>0&&(o=h+i,a>o||(r.push(this.m.slice(h,o)),o=h,this.W(this.S,o,917501)),n>this.p.maxDstSize))throw new p(`decomp size ${n}b>maxDstSize lim ${this.p.maxDstSize}b`)}e+=i}return o!=h&&r.push(this.m.slice(h,o)),{buf:i(r,n),in_offset:t.length}}destroy(){this.A=this.U=this.M=this._=this.S=this.i=this.h=this.o=this.m=this.l=null}},e={t:null,bufSizes:{maxSrcSize:0,maxDstSize:0},dictionaries:[]},h=new Map,o=new Map,a=!1,f=new Map,w=t=>{if(6>t.length)return 0;try{const i=S(t),s="object"==typeof i?i.d:0;return s>0&&f.set(s,t),s}catch{return 0}},u=async(i={})=>(a||(c=await e.t(i.wasmPath),a=!0),t(i.dictionary)),m=t=>t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t);class U{readable;writable;constructor(t){let n,e=-1,h=0,o=!0,a=[],c={d:0,u:0,e:-1},f=0,u=0,d=0,y=262144;const{readable:_,writable:b}=new TransformStream({async transform(i,r){const l=m(i);if(f+=l.length,a.push(l),d++,f>=12){if(-1==c.e){const t=new Uint8Array(f);let i=0;for(let s=0;d>s;s++)t.set(a[s],i),i+=a[s].length;c=S(t),y=Math.max(y,c.e,Math.max(c.u>>4,1<<17))}if(f>=y&&-1!=c.e){if(n){const t=n.decompressStream(l,!1).buf;return void(t.length>0&&r.enqueue(t))}try{o&&(h=w(l),[n,e,h]=await s(h,t));const i=n.decompressStream(l,o).buf;u+=i.length,r.enqueue(i),o=!1}catch(t){r.error(new p("decomp err "+t))}}}},async flush(s){if(0==u&&f>6)try{const r=await l(i(a,f),!0,t);s.enqueue(r.buf)}catch(t){s.error(new p("decomp err "+t))}else-1==e?n?.destroy():r(e,h);s.terminate()}});this.readable=_,this.writable=b}}d=async(t,i)=>(await l(t,!0,i)).buf,l=async(t,i=!1,n)=>{const e=w(t),[h,o]=await s(e,n),a=h.decompressStream(t,i);return-1===o?h.destroy():r(o,e),a},y=async(t,i,n)=>{const e=w(t),[h,o]=await s(e,n),a=h.decompressSync(t,i);return-1===o?h.destroy():r(o,e),a};import{readFileSync as M}from"fs";e.t=()=>{const t=new URL("./zstd-decoder-perf.wasm",import.meta.url);return new WebAssembly.Module(M(t))};export{y as decompressSync,l as decompressStream,d as decompress,u as createDecoder,U as ZstdDecompressionStream,n as ZstdDecoder};