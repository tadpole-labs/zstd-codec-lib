{
  "version": 3,
  "sources": ["../utils.ts", "../zstd-wasm.ts", "../shared.ts", "../index.web.inlined.ts"],
  "sourcesContent": [
    "/**\n * ZSTD frame header parsing utilities.\n * \n * @author 101arrowz\n * @see https://github.com/101arrowz/fzstd/blob/master/src/index.ts\n */\n\nexport const err = Error;\nexport interface DZS {\n  d: number;  // dictionary ID\n  u: number;  // uncompressed size\n  e: number;  // window size\n}\n\nexport const rb = /* @__PURE__ */ (d: Uint8Array, b: number, n: number) => {\n  let i = 0, o = 0;\n  for (; i < n; ++i) o |= d[b++] << (i << 3);\n  return o;\n};\n\n\nexport const _fss = (dat: Uint8Array): number => {\n  const flg = dat[4];\n  const ss = (flg >> 5) & 1, df = flg & 3, fcf = flg >> 6;\n  // @ts-expect-error\n  return rb(dat, (6 - ss) + df == 3 ? 4 : df, fcf ? (1 << fcf) : ss) + ((fcf == 1) && 256);\n}\n\n// Read Zstandard frame header\nexport const rzfh = /* @__PURE__ */ (dat: Uint8Array): number | DZS => {\n  if ((dat[0] | (dat[1] << 8) | (dat[2] << 16)) == 0x2FB528 && dat[3] == 253) {\n    // Zstandard frame\n    const flg = dat[4];\n    // single segment, checksum, dict flag, frame content flag\n    const ss = (flg >> 5) & 1, df = flg & 3, fcf = flg >> 6;\n    if (flg & 8) throw new err('invalid zstd data'); // Reserved bit check\n    // byte\n    let bt = 6 - ss;\n    // dict bytes\n    const db = df == 3 ? 4 : df;\n    // dictionary id\n    const di = rb(dat, bt, db);\n    // @ts-expect-error\n    const fss = rb(dat, bt + db, fcf ? (1 << fcf) : ss) + ((fcf == 1) && 256);\n    // window size\n    let ws = fss;\n    if (!ss) {\n      // window descriptor\n      const wb = 1 << (10 + (dat[5] >> 3));\n      ws = wb + (wb >> 3) * (dat[5] & 7);\n    }\n    if (ws > 2145386496) throw new err('win size 2 large');\n    return {\n      d: di,\n      e: ws,\n      u: fss\n    };\n  }\n  throw new err('invalid zstd data');\n};\n",
    "import type { DecoderWasmExports, DecoderOptions, StreamResult } from './types.js';\nimport { _concatUint8Arrays } from './shared.js';\nimport { _fss, err } from './utils.js';\n/**\n * ╔══════════════════════════════════════════════════════════════╗\n * ║                        Memory Layout                         ║\n * ╠══════════════════════════════════════════════════════════════╣\n * ║   0x0000   ┌────────────────────────────────────┐            ║\n * ║            │      Stack Space (8 KB)            │            ║\n * ║   0x2000   ├────────────────────────────────────┤            ║\n * ║            │   ZSTD_DCtx Context (~64 KB)       │            ║\n * ║            │   (Decompression context +         │            ║\n * ║            │    workspace)                      │            ║\n * ║ ~0x12000   ├────────────────────────────────────┤            ║\n * ║            │   Dictionary (optional)            │            ║\n * ║            │   (up to 2 MB)                     │            ║\n * ║            │   (only allocated if provided)     │            ║\n * ║    +2MB    ├────────────────────────────────────┤            ║\n * ║            │  Stream Structs (24 bytes):        │            ║\n * ║            │    ┌─────────────────────────┐     │            ║\n * ║            │    │ ZSTD_inBuffer (12b)     │     │            ║\n * ║            │    │ - srcPtr  (4 bytes)     │     │            ║\n * ║            │    │ - size    (4 bytes)     │     │            ║\n * ║            │    │ - pos     (4 bytes)     │     │            ║\n * ║            │    ├─────────────────────────┤     │            ║\n * ║            │    │ ZSTD_outBuffer (12b)    │     │            ║\n * ║            │    │ - dstPtr  (4 bytes)     │     │            ║\n * ║            │    │ - size    (4 bytes)     │     │            ║\n * ║            │    │ - pos     (4 bytes)     │     │            ║\n * ║            │    └─────────────────────────┘     │            ║\n * ║    +24b    ├────────────────────────────────────┤            ║\n * ║            │    Source Buffer (2 MB)            │            ║\n * ║            │    (Compressed input staging)      │            ║\n * ║    +2MB    ├────────────────────────────────────┤            ║\n * ║            │    Destination Buffer (8.4 MB)     │            ║\n * ║            │    + 1mb margin                    │            ║\n * ║            │  Sized for level 19 compression:   │            ║\n * ║            │  windowSize (8MB) + 3*blockSize    │            ║\n * ║            │  (384KB) + 64 bytes                │            ║\n * ║  +9.4MB    └────────────────────────────────────┘            ║\n * ║                                                              ║\n * ║ Total: ~13.5 MB (with dict), ~11.5 MB (without dict)         ║\n * ╠══════════════════════════════════════════════════════════════╣\n * ║                         Notes                                ║\n * ╠══════════════════════════════════════════════════════════════╣\n * ║ • This memory layout supports decompression of files         ║\n * ║   compressed at any level up to lvl 19                       ║\n * ║                                                              ║\n * ║ • Input/output does NOT have to fit within these buffer      ║\n * ║   limits. As long as user-configured maxSrcSize & maxDstSize ║\n * ║   aren't crossing the limits, we can decompress arbitrarily  ║\n * ║   large files through streaming                              ║\n * ║                                                              ║\n * ║ • For small files that fit in the buffers, we use fast sync  ║\n * ║   decompression. For larger files, we automatically fallback ║\n * ║   to streaming decompression                                 ║\n * ║                                                              ║\n * ║ • Memory is managed primarily from JS by resetting buffer    ║\n * ║   pointers back to dstPtr at every freshly initialized       ║\n * ║   stream, avoiding WASM heap growth                          ║\n * ║                                                              ║\n * ║ • The WASM memory can grow into the JS runtime if needed,    ║\n * ║   but we size the initial allocation to handle most common   ║\n * ║   cases without heap growth needed at all                    ║\n * ╚══════════════════════════════════════════════════════════════╝\n */\n\n\n/**\n *    \n *    https://github.com/facebook/zstd/blob/release/lib/decompress/zstd_decompress.c#L1980\n * \n *    Level 19 memory requirements:\n *\n *  - windowSize:          8 MB     8 * 1024 * 1024 bytes\n * \n *  - 3 * blockSize:     384 KB     3 * 128 KB = 384 KB = 3 * 131072 bytes\n * \n *  - Safety margin:   64 bytes     for fast memcpy functions that may\n *                                  read/write slightly out of bounds\n *\n *    Total Memory = blockSize + (windowSize + 2 * blockSize + 2 * WILDCOPY_OVERLENGTH)\n * \n *\n *    Other relevant sources:\n *      - Zstandard decompressor errata:\n *          https://github.com/facebook/zstd/blob/release/doc/decompressor_errata.md\n *      - Permissiveness / Edge-Cases:\n *          https://github.com/facebook/zstd/blob/release/doc/decompressor_permissive.md\n *      - Zstd manual:\n *          https://facebook.github.io/zstd/zstd_manual.html\n */\n\nconst _MAX_DST_BUF = 9830464;  // 9.37 MB\nexport const _MAX_SRC_BUF = 2 * 1024 * 1024;  // 2 MB input buffer\nconst _STREAM_RESULT: StreamResult = { buf: new Uint8Array(0), in_offset: 0 };\nclass ZstdDecoder {\n  private _wasm!: WebAssembly.Instance;\n  private _exports!: DecoderWasmExports;\n  private _memory!: WebAssembly.Memory;\n  private _HEAPU8!: Uint8Array;\n  private _HEAPU32!: Uint32Array;\n  \n  private readonly _options: {\n    dictionary?: Uint8Array;\n    maxSrcSize: number;\n    maxDstSize: number;\n  };\n\n  // Memory pointers\n  private _streamInputStructPtr: number = 0;\n  private _streamOutputStructPtr: number = 0;\n  private _ddict: number = 0;\n  private _srcPtr: number = 0;\n  private _dstPtr: number = 0;\n\n  private _bufferDstSize: number = _MAX_DST_BUF;\n  \n  constructor(options: DecoderOptions = {}) {\n    this._options = {\n      dictionary: options.dictionary,\n      maxSrcSize: Math.max(options.maxSrcSize || 0, _MAX_DST_BUF<<6),\n      maxDstSize: Math.max(options.maxDstSize || 0, _MAX_DST_BUF<<6)\n    };\n  }\n\n  /**\n   * Initialize with a compiled WebAssembly module\n   */\n  init(wasmModule: WebAssembly.Module): ZstdDecoder {\n    this._wasm = new WebAssembly.Instance(wasmModule, { env: {} });;\n    return this._initCommon();\n  }\n\n  /**\n   * Initialize with an existing WebAssembly instance\n   */\n  _initWithInstance(wasmInstance: WebAssembly.Instance, _wasmModule?: WebAssembly.Module): ZstdDecoder {\n    this._wasm = wasmInstance;\n    return this._initCommon();\n  }\n\n  private _initCommon(): ZstdDecoder {\n    this._exports = this._wasm.exports as unknown as DecoderWasmExports;\n    this._memory = (this._wasm.exports).memory as WebAssembly.Memory;\n\n    this._HEAPU8 = new Uint8Array(this._memory.buffer);\n    this._HEAPU32 = new Uint32Array(this._memory.buffer);\n\n    // Reserve space for the streaming buffer structs:\n    // - ZSTD_inBuffer (12 bytes): { srcPtr, size, pos }\n    // - ZSTD_outBuffer (12 bytes): { dstPtr, size, pos }\n    // We'll keep both structs contiguous in memory.\n    // Allocate 24 bytes for both structs in one go\n    this._streamInputStructPtr = 8196;\n    // Output buffer struct goes after input's 12 bytes.\n    this._streamOutputStructPtr = this._streamInputStructPtr + 12;\n\n    this._exports.createDCtx();\n\n    // Initialize dictionary if provided\n    if (this._options.dictionary) {\n      const _dictLen = this._options.dictionary.length\n      if (_dictLen > _MAX_SRC_BUF*2) {\n        throw new err('dict>2mb max size');\n      }\n      const dictPtr = this._malloc(_dictLen);\n      this._HEAPU8.set(this._options.dictionary as Uint8Array, dictPtr);\n      this._ddict = this._exports.createDict(dictPtr, _dictLen);\n    }\n    this._srcPtr = this._malloc(_MAX_SRC_BUF);\n    this._dstPtr = this._srcPtr + _MAX_SRC_BUF // We don't malloc dst buf. Its where dst buf starts. Zstd will malloc\n    return this;\n  }\n\n  /**\n   * Allocate memory in WASM module\n   */\n  private _malloc(size: number): number {\n    return this._exports.malloc(size);\n  }\n\n  /**\n   * Simple API: Decompress a buffer synchronously\n   * Falls back to asynchronous compression if the expected size\n   * is not hinted in advance.\n   * \n   * From measurements taken, it is more efficient to fallback\n   * to streaming than to attempt to infer the expected size from the headers.\n   * \n   * @param compressedData - Compressed data\n   * @param expectedSize - Optional expected decompressed size. If not provided, falls back to streaming.\n   * @returns Decompressed data\n   */\n  decompressSync(compressedData: Uint8Array, expectedSize?: number): Uint8Array {\n    if (!this._exports) throw new err('not initialized');\n    \n    const srcSize = compressedData.length;\n    \n    if (srcSize > this._options.maxSrcSize ) {\n      throw new err(`comp data ${srcSize}b>maxSrcSize lim ${this._options.maxSrcSize}b)`);\n    }\n    \n    if(!expectedSize) expectedSize = _fss(compressedData)\n    \n    // No expected size, or above thresholds for single pass => Use streaming\n    if (!expectedSize || expectedSize > _MAX_DST_BUF || srcSize > _MAX_SRC_BUF) {\n      return this.decompressStream(compressedData, true).buf;\n    }\n    \n    this._HEAPU8.set(compressedData as Uint8Array, this._srcPtr);\n    this._exports.prune_buf(this._dstPtr);\n    const _dstPtr = this._dstPtr\n    const result = this._exports.decompressSync(\n      _dstPtr,\n      this._bufferDstSize,\n      this._srcPtr,\n      srcSize,\n      this._ddict\n    );\n\n    if (result < 0) {\n      throw new err(`decomp err ${result}`);\n    }\n    return this._HEAPU8.slice(_dstPtr, _dstPtr + result);\n  }\n\n\n  /**\n   * Optimized struct write using Uint32Array when properly aligned / (JIT)\n   */\n  private _writeStreamStruct(ptr: number, bufPtr: number, size: number): void {\n    const u32Index = ptr >>> 2;\n    this._HEAPU32[u32Index] = bufPtr;\n    this._HEAPU32[u32Index + 1] = size;\n    this._HEAPU32[u32Index + 2] = 0;\n  }\n  \n  /**\n   * Optimized struct read using Uint32Array\n   */\n  private _readStreamPos(ptr: number): number {\n    return this._HEAPU32[(ptr + 8) >>> 2];\n  }\n\n  /**\n   * Streadming decompression - can be fed chunks incrementally\n   * \n   * @param input - Input chunk\n   * @param reset - Reset stream for new decompression (default: false)\n   * @returns Decompression result with buffer, code, and input offset\n   */\n  decompressStream(input: Uint8Array, reset = false): StreamResult {\n    if (!this._exports) throw new err('not initialized');\n    \n    // Reset stream state for new decompression - ZSTD_reset_session_only = 1\n    if (reset) {\n      this._exports.reset();\n\n      if (this._ddict) this._exports.refDict(this._ddict);\n\n      this._exports.prune_buf(this._dstPtr);\n    }\n    if (!input || input.length === 0) return _STREAM_RESULT;\n\n    const output: Uint8Array[] = [];\n    \n    let totalOutputSize = 0;\n    let offset = 0;\n\n    // const 128kb less overhead than adaptive input\n    const suggestedInputSize = 131075; //ZSTD_BLOCKSIZE_MAX + ZSTD_BLOCKHEADERSIZE (131072 + 3)\n\n    // Assuming 4-8x compressability in the average case\n    // Write to src buf less.\n    // Let 1mb - 128kb out buf accumulate before we flush it out back to js\n    const dstBufStart = this._srcPtr + 262150 \n    let dstOffset = dstBufStart;\n    let dstMaxBuf = dstBufStart + 655360\n    let lastOut = 0\n    while (offset < input.length) {\n      const toProcess = Math.min(Math.min(input.length - offset, suggestedInputSize), 262150);\n      this._HEAPU8.set((input as Uint8Array).subarray(offset, offset + toProcess), this._srcPtr);\n      \n      this._writeStreamStruct(this._streamInputStructPtr, this._srcPtr, toProcess);\n\n      if(dstOffset == dstBufStart) {\n        this._writeStreamStruct(this._streamOutputStructPtr, dstOffset, 917501);\n      }\n      \n      // Process all data in current block\n      while (this._readStreamPos(this._streamInputStructPtr) < toProcess) {\n        const result = this._exports.decStream();\n        if (result < 0) throw new err(`decomp err ${result}`);\n        \n        const outputPos = this._readStreamPos(this._streamOutputStructPtr);\n\n        totalOutputSize += dstOffset == dstBufStart ? outputPos : (outputPos - lastOut);\n        lastOut = outputPos\n        if (outputPos > 0) {\n\n          dstOffset = dstBufStart + outputPos\n\n          if(dstOffset >= dstMaxBuf) {\n            output.push(this._HEAPU8.slice(dstBufStart, dstOffset));\n            dstOffset = dstBufStart;\n            this._writeStreamStruct(this._streamOutputStructPtr, dstOffset, 917501);\n          }\n          \n          if (totalOutputSize > this._options.maxDstSize) {\n            throw new err(`decomp size ${totalOutputSize}b>maxDstSize lim ${this._options.maxDstSize}b`);\n          }\n        }\n      }\n      offset += toProcess;\n    }\n\n    // Flush remaining chunk\n    if (dstOffset != dstBufStart) output.push(this._HEAPU8.slice(dstBufStart, dstOffset));\n    \n    return {\n      buf: _concatUint8Arrays(output, totalOutputSize),\n      in_offset: input.length,\n    };\n  }\n\n  /**\n   * Clean up ZSTD contexts\n   */\n  destroy(): void {\n    //@ts-expect-error gc.\n    this._ddict = this._srcPtr = this._dstPtr = this._streamInputStructPtr = this._streamOutputStructPtr = this._wasm = this._exports = this._memory = this._HEAPU8 = this._HEAPU32 = null;\n  }\n}\n\nexport default ZstdDecoder;\nexport { ZstdDecoder };\nexport type { DecoderOptions, StreamResult } from './types.js';\n",
    "import ZstdDecoder from './zstd-wasm.js';\nexport { default as ZstdDecoder, _MAX_SRC_BUF } from './zstd-wasm.js';\n\n\nimport type { StreamResult, ZstdOptions } from './types.js';\nimport { rzfh, DZS, err } from './utils.js';\n\nexport const _internal = {\n  _loader: null as ((wasmPath?: string) => WebAssembly.Module | Promise<WebAssembly.Module>) | null,\n  bufSizes: { \n    maxSrcSize: 0,\n    maxDstSize: 0\n  },\n  dictionaries: [] as string[]\n};\n\n// This is horrible tbh.\nconst decoderPools = new Map<number, Map<number, ZstdDecoder>>();\nconst poolLocks = new Map<number, boolean[]>();\n// Survives hundreds of concurrent promises though without screwing browser mem\n// Something that shouldn't normally occur assuming common sense. Still good to know it survies misuse\n// Spinning up instances is cheap, but still not too cheap. So this is the middle ground. Without overengineering with web workers, another GC layer in JS etc. Prolly could get away with just one hot instance. And get rid of the above too\n\nlet isInitialized = false;\nlet cachedModule: WebAssembly.Module;\n\nconst loadedDictionaries = new Map<number, Uint8Array>();\n\nfunction /* @__PURE__ */ _createDecoderInstance(dictionary?: Uint8Array | ArrayBuffer | Request | string): ZstdDecoder {\n  const dict = dictionary instanceof Uint8Array ? dictionary :\n               dictionary instanceof ArrayBuffer ? new Uint8Array(dictionary) :\n               undefined;\n  \n  const decoder = new ZstdDecoder({ ..._internal.bufSizes, dictionary: dict });\n  decoder.init(cachedModule);\n  return decoder;\n}\n\nexport const setupZstdDecoder = /* @__PURE__ */ async (options: {\n  maxSrcSize?: number;\n  maxDstSize?: number;\n  dictionaries?: string[];  // URLs or data:uris\n}) => {\n  if (options.maxSrcSize) _internal.bufSizes.maxSrcSize = options.maxSrcSize;\n  if (options.maxDstSize) _internal.bufSizes.maxDstSize = options.maxDstSize;\n  \n  if (options.dictionaries) {\n    for (const url of options.dictionaries) {\n      const dict = await loadResource(url);\n      const id = _getDictId(dict);\n      if (id > 0) loadedDictionaries.set(id, dict);\n    }\n  }\n};\n\nexport function _concatUint8Arrays(arrays: Uint8Array[], ol: number): Uint8Array {\n  if (arrays.length === 1) return arrays[0];\n  const buf = new Uint8Array(ol);\n  for (let i = 0, b = 0; i < arrays.length; ++i) {\n    const chk = arrays[i];\n    buf.set(chk, b);\n    b += chk.length;\n  }\n  return buf;\n}\n\nasync function _acquireDecoder(dictId: number = 0, options?: ZstdOptions): Promise<[ZstdDecoder, number, number]> {\n  if (!cachedModule) {\n    const module = _internal._loader!();\n    cachedModule = module instanceof Promise ? await module : module;\n  }\n\n  if (!decoderPools.has(dictId)) {\n    decoderPools.set(dictId, new Map());\n    poolLocks.set(dictId, []);\n  }\n  \n  const pool = decoderPools.get(dictId)!;\n  const locks = poolLocks.get(dictId)!;\n  \n  // \n  for (let i = 0; i < locks.length; i++) {\n    if (!locks[i]) {\n      locks[i] = true;\n      return [pool.get(i)!, i, dictId];\n    }\n  }\n  \n  const dictionary = options?.dictionary || loadedDictionaries.get(dictId);\n  const decoder = _createDecoderInstance(dictId > 0 ? dictionary : undefined);\n  \n  if (locks.length >= 2) return [decoder, -1, dictId];\n  \n  const newIdx = locks.length;\n  pool.set(newIdx, decoder);\n  locks.push(true);\n  return [decoder, newIdx, dictId];\n}\n\nfunction _releaseDecoder(idx: number, dictId: number): void {\n  const locks = poolLocks.get(dictId);\n  if (locks) locks[idx] = false;\n}\n\nexport function _pushToPool(decoder: ZstdDecoder, module: WebAssembly.Module, dictId: number = 0): void {\n  cachedModule = module;\n  if (!decoderPools.has(dictId)) {\n    decoderPools.set(dictId, new Map());\n    poolLocks.set(dictId, []);\n  }\n  const pool = decoderPools.get(dictId)!;\n  const locks = poolLocks.get(dictId)!;\n  pool.set(locks.length, decoder);\n  locks.push(false);\n}\n\n/**\n * Load resource as Uint8Array\n */\nconst loadResource = /* @__PURE__ */ async (resource: Uint8Array | ArrayBuffer | Request | string): Promise<Uint8Array> => {\n  if (resource instanceof Uint8Array) return resource;\n  if (resource instanceof ArrayBuffer) return new Uint8Array(resource);\n  const response = await fetch(resource);\n  return new Uint8Array(await response.arrayBuffer());\n};\n\n/**\n * Get dictionary ID from frame header\n */\nconst _getDictId = /* @__PURE__ */ (input: Uint8Array): number => {\n  if (input.length < 6) return 0;\n  try {\n    const header = rzfh(input);\n    const id = typeof header === 'object' ? header.d : 0;\n    if (id > 0) loadedDictionaries.set(id, input);\n    return id;\n  } catch {\n    return 0;\n  }\n};\n\n/**\n * Create a decoder instance\n */\nexport const createDecoder = /* @__PURE__ */ async (options: ZstdOptions = {}): Promise<ZstdDecoder> => {\n  if (!isInitialized) {\n    cachedModule = await _internal._loader!(options.wasmPath);\n    isInitialized = true;\n  }\n  return _createDecoderInstance(options.dictionary);\n};\n\n/**\n * Convert BufferSource to Uint8Array\n */\nconst _toUint8Array = (chunk: BufferSource): Uint8Array => {\n  if (chunk instanceof Uint8Array) return chunk;\n  if (ArrayBuffer.isView(chunk))\n    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n  return new Uint8Array(chunk as ArrayBuffer);\n};\n\n\n/**\n * ZstdDecompressionStream\n */\nexport class ZstdDecompressionStream {\n  readonly readable: ReadableStream;\n  readonly writable: WritableStream;\n\n  constructor(options?: ZstdOptions) {\n    let decoder: ZstdDecoder;\n    let idx: number = -1;\n    let dictId: number = 0;\n    let isFirstChunk = true;\n    // A temporary buffer to hold data until the header can be read.\n    let initialBuffer: Uint8Array[] = [];\n    let headerInfo: DZS = { d: 0, u: 0, e: -1 };\n    let bytesRead: number = 0\n    let bytesWritten: number = 0\n    let bufLen: number = 0\n    let minRecvSize: number = 262144\n\n    const { readable, writable } = new TransformStream<BufferSource, Uint8Array>({\n      async transform(chunk: BufferSource, controller: TransformStreamDefaultController<Uint8Array>) {\n        const data = _toUint8Array(chunk)\n        bytesRead += data.length\n        initialBuffer.push(data)\n        bufLen++\n        if(bytesRead < 12) {\n          return;\n        } else if(headerInfo.e == -1) {\n          const headerBuffer = new Uint8Array(bytesRead);\n          let offset = 0;\n          for (let i = 0; i < bufLen; i++) {\n            headerBuffer.set(initialBuffer[i], offset);\n            offset += initialBuffer[i].length;\n          }\n          headerInfo = rzfh(headerBuffer) as DZS;\n          minRecvSize = Math.max(minRecvSize, headerInfo.e, Math.max(headerInfo.u>>4, 1<<17))\n        }\n        if(bytesRead < minRecvSize || headerInfo.e == -1 ) return;\n        \n        if (decoder) {\n          const result = decoder.decompressStream(data, false).buf;\n          if (result.length > 0) {\n            controller.enqueue(result);\n          }\n          return;\n        }\n        \n        try {\n          if (isFirstChunk) {\n            dictId = _getDictId(data);\n            [decoder, idx, dictId] = await _acquireDecoder(dictId, options);\n          }\n          \n          const result = decoder!.decompressStream(data, isFirstChunk).buf;\n          bytesWritten += result.length\n          controller.enqueue(result);\n          isFirstChunk = false;\n        } catch (er) {\n          controller.error(new err(`decomp err ${er}`));\n        }\n      },\n\n      async flush(controller: TransformStreamDefaultController<Uint8Array>) {\n        if(bytesWritten == 0 && bytesRead > 6) {\n          try {\n            const res = await decompressStream(_concatUint8Arrays(initialBuffer, bytesRead), true, options);\n            controller.enqueue(res.buf);\n          } catch (er) {\n            controller.error(new err(`decomp err ${er}`));\n          }\n        } else {\n          if(idx == -1) {\n            decoder?.destroy();\n          } else {\n            _releaseDecoder(idx, dictId);\n          }\n        }\n        controller.terminate();\n      }\n    });\n\n    this.readable = readable;\n    this.writable = writable;\n  }\n}\n\n/**\n * Decompress data in-full\n * (Proxies to decompressStream and returns the buf)\n */\nexport const decompress = /* @__PURE__ */ async (\n  input: Uint8Array,\n  options?: ZstdOptions\n): Promise<Uint8Array> => {\n  return (await decompressStream(input, true, options)).buf;\n};\n\n/**\n * Decompress data as a stream\n */\nexport const decompressStream = /* @__PURE__ */ async (\n  input: Uint8Array,\n  reset = false,\n  options?: ZstdOptions\n): Promise<StreamResult> => {\n  const dictId = _getDictId(input);\n  const [decoder, idx] = await _acquireDecoder(dictId, options);\n  const result = decoder.decompressStream(input, reset);\n  idx === -1 ? decoder.destroy() : _releaseDecoder(idx, dictId);\n  return result;\n};\n\n/**\n * Decompress data synchronously (when expected size is known)\n */\nexport const decompressSync = /* @__PURE__ */ async (\n  input: Uint8Array,\n  expectedSize?: number,\n  options?: ZstdOptions\n): Promise<Uint8Array> => {\n  const dictId = _getDictId(input);\n  const [decoder, idx] = await _acquireDecoder(dictId, options);\n  const result = decoder.decompressSync(input, expectedSize);\n  idx === -1 ? decoder.destroy() : _releaseDecoder(idx, dictId);\n  return result;\n};\n",
    "/**\n * Zstd WASM Decoder - Inlined WASM variant\n * \n * WASM is pre-compressed with deflate-raw level 7, encoded as base64,\n * then decompressed at runtime using DecompressionStream\n */\n\nimport { _internal } from './shared.js';\n\nexport { \n  ZstdDecoder,\n  createDecoder,\n  ZstdDecompressionStream,\n  decompress,\n  decompressStream,\n  decompressSync\n} from './shared.js';\n\nexport type { DecoderOptions, StreamResult } from './types.js';\n\n_internal._loader = async () => {\n\n  return await WebAssembly.compile(await new Response(\n    new Blob([typeof (Uint8Array as any).fromBase64 === 'function'\n      ? (Uint8Array as any).fromBase64(WASM_BASE64)\n      : new TextEncoder().encode(atob(WASM_BASE64)).buffer])\n      .stream()\n      .pipeThrough(new DecompressionStream('deflate-raw'))\n  ).arrayBuffer());\n};\nconst WASM_BASE64 = '__WASM_BASE64_PLACEHOLDER__';"
  ],
  "mappings": "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",
  "debugId": "1D523FC03636305364756E2164756E21",
  "names": []
}