function t(t){const i=t instanceof Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):void 0,r=new n({...e.bufferSizes,dictionary:i});return r.init(c),r}function i(t,i){if(1===t.length)return t[0];const r=new Uint8Array(i);for(let i=0,s=0;t.length>i;++i){const n=t[i];r.set(n,s),s+=n.length}return r}async function r(i=0,r){if(!c){const t=e.t();c=t instanceof Promise?await t:t}o.has(i)||(o.set(i,new Map),h.set(i,[]));const s=o.get(i),n=h.get(i);for(let t=0;n.length>t;t++)if(!n[t])return n[t]=!0,[s.get(t),t,i];const a=r?.dictionary||f.get(i),u=t(i>0?a:void 0);if(n.length>=3)return[u,-1,i];const d=n.length;return s.set(d,u),n.push(!0),[u,d,i]}function s(t,i){const r=h.get(i);r&&(r[t]=!1)}var n,e,o,h,a,c,f,u,d,w,m,l,y,S=(t,i,r)=>{let s=0,n=0;for(;r>s;++s)n|=t[i++]<<(s<<3);return n},_=t=>{if(3126568==(t[0]|t[1]<<8|t[2]<<16)&&253==t[3]){const i=t[4],r=i>>5&1,s=3&i,n=i>>6;if(8&i)throw Error("invalid zstd data");let e=6-r;const o=3==s?4:s,h=S(t,e,o),a=S(t,e+o,n?1<<n:r)+(1==n&&256);let c=a;if(!r){const i=1<<10+(t[5]>>3);c=i+(i>>3)*(7&t[5])}if(c>2145386496)throw Error("window size too large");return{d:h,e:c,u:a}}throw Error("invalid zstd data")},p=9830464,b=2097152,A={buf:new Uint8Array(0),code:0,in_offset:0};n=class{i;o;h;m;l;S;_=0;p=0;A=0;U=0;M=0;P=p;constructor(t={}){this.S={dictionary:t.dictionary,maxSrcSize:t.maxSrcSize||0,maxDstSize:t.maxDstSize||0}}init(t){return this.i=new WebAssembly.Instance(t,{env:{}}),this.v()}D(t,i){return this.i=t,this.v()}v(){if(this.o=this.i.exports,this.h=this.i.exports.memory,this.m=new Uint8Array(this.h.buffer),this.l=new Uint32Array(this.h.buffer),this._=this.W(24),this.p=this._+12,this.o.createDCtx(),this.S.dictionary){const t=this.S.dictionary.length;if(t>4194304)throw Error("dict>2mb max size");const i=this.W(t);this.m.set(this.S.dictionary,i),this.A=this.o.createDict(i,t)}return this.U=this.W(b),this.M=this.U+b,this}W(t){return this.o.bmalloc(t)}decompressSync(t,i){if(!this.o)throw Error("module not initialized");const r=t.length;if(r>this.S.maxSrcSize)throw Error(`comp data ${r}b>maxSrcSize lim ${this.S.maxSrcSize}b)`);if(i||(i=(t=>{const i=t[4],r=i>>5&1,s=3&i,n=i>>6;return S(t,6-r+s==3?4:s,n?1<<n:r)+(1==n&&256)})(t)),!i||i>p||r>b)return this.decompressStream(t,!0).buf;this.m.set(t,this.U),this.o.prune_buf(this.M);const s=this.M,n=this.o.decompressSync(s,this.P,this.U,r,this.A);if(0>n)throw Error("decomp failed err "+n);return this.m.slice(s,s+n)}$(t,i,r){const s=t>>>2;this.l[s]=i,this.l[s+1]=r,this.l[s+2]=0}B(t){return this.l[t+8>>>2]}decompressStream(t,r=!1){if(!this.o)throw Error("WASM module not initialized");r&&(this.o.reset(),this.A&&this.o.refDict(this.A),this.o.prune_buf(this.M));let s=A;if(!t||0===t.length)return s;const n=[];let e=0,o=0;const h=this.U+262150;let a=h,c=h+655360,f=0;for(;t.length>o;){const i=Math.min(Math.min(t.length-o,131075),262150);for(this.m.set(t.subarray(o,o+i),this.U),this.$(this._,this.U,i),a==h&&this.$(this.p,a,917501);this.B(this._)<i;){const t=this.o.decStream(this.p,this._);if(0>t)throw Error("decomp err "+t);const i=this.B(this.p);if(e+=a==h?i:i-f,f=i,i>0&&(a=h+i,c>a||(n.push(this.m.slice(h,a)),a=h,this.$(this.p,a,917501)),e>this.S.maxDstSize))throw Error(`decomp size ${e}b>maxDstSize lim ${this.S.maxDstSize}b`)}o+=i}return a!=h&&n.push(this.m.slice(h,a)),s={buf:i(n,e),code:0,in_offset:t.length},s}destroy(){this.A=this.U=this.M=this._=this.p=this.i=this.o=this.h=this.m=this.l=null}},e={t:null,bufferSizes:{maxSrcSize:67108864,maxDstSize:134217728},dictionaries:[]},o=new Map,h=new Map,a=!1,f=new Map,u=t=>{if(6>t.length)return 0;try{const i=_(t),r="object"==typeof i?i.d:0;return r>0&&f.set(r,t),r}catch{return 0}},d=async(i={})=>{if(!a){const t=e.t(i.wasmPath);c=t instanceof Promise?await t:t,a=!0}return t(i.dictionary)},w=t=>t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t);class z{readable;writable;constructor(t){let n,e=-1,o=0,h=!0,a=[],c={d:0,u:0,e:-1},f=0,d=0,m=0,y=262144;const{readable:S,writable:p}=new TransformStream({async transform(i,s){const l=w(i);if(f+=l.length,a.push(l),m++,f>=12){if(-1==c.e){const t=new Uint8Array(f);let i=0;for(let r=0;m>r;r++)t.set(a[r],i),i+=a[r].length;c=_(t),y=Math.max(y,c.e,Math.max(c.u>>4,1<<17))}if(f>=y&&-1!=c.e){if(n){const t=n.decompressStream(l,!1).buf;return void(t.length>0&&s.enqueue(t))}try{h&&(o=u(l),[n,e,o]=await r(o,t));const i=n.decompressStream(l,h).buf;d+=i.length,s.enqueue(i),h=!1}catch(t){s.error(Error("Decompression error: "+t))}}}},async flush(r){if(0==d&&f>6)try{const s=await l(i(a,f),!0,t);r.enqueue(s.buf)}catch(t){r.error(Error("Decompression error: "+t))}else-1==e?n?.destroy():s(e,o);r.terminate()}});this.readable=S,this.writable=p}}m=async(t,i)=>(await l(t,!0,i)).buf,l=async(t,i=!1,n)=>{const e=u(t),[o,h]=await r(e,n),a=o.decompressStream(t,i);return-1===h?o.destroy():s(h,e),a},y=async(t,i,n)=>{const e=u(t),[o,h]=await r(e,n),a=o.decompressSync(t,i);return-1===h?o.destroy():s(h,e),a},e.t=async t=>{const i=t||new URL("./zstd-decoder.wasm",import.meta.url).href,r=await fetch(i);return await WebAssembly.compileStreaming(r)};export{y as decompressSync,l as decompressStream,m as decompress,d as createDecoder,z as ZstdDecompressionStream,n as ZstdDecoder};