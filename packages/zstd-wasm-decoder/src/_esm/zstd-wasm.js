function t(t,i){if(1===t.length)return t[0];const s=new Uint8Array(i);for(let i=0,h=0;t.length>i;++i){const r=t[i];s.set(r,h),h+=r.length}return s}var i,s=Error,h=(new Map,new Map,new Map,9830464),r=2097152,e={buf:new Uint8Array(0),in_offset:0};class n{t;i;h;o;m;u;_=0;l=0;p=0;S=0;A=0;M=h;constructor(t={}){this.u={dictionary:t.dictionary,maxSrcSize:Math.max(t.maxSrcSize||0,h<<6),maxDstSize:Math.max(t.maxDstSize||0,h<<6)}}init(t){return this.t=new WebAssembly.Instance(t,{env:{}}),this.P()}U(t,i){return this.t=t,this.P()}P(){if(this.i=this.t.exports,this.h=this.t.exports.memory,this.o=new Uint8Array(this.h.buffer),this.m=new Uint32Array(this.h.buffer),this._=8196,this.l=this._+12,this.i.createDCtx(),this.u.dictionary){const t=this.u.dictionary.length;if(t>4194304)throw new s("dict>2mb max size");const i=this.$(t);this.o.set(this.u.dictionary,i),this.p=this.i.createDict(i,t)}return this.S=this.$(r),this.A=this.S+r,this}$(t){return this.i.malloc(t)}decompressSync(t,i){if(!this.i)throw new s("not initialized");const e=t.length;if(e>this.u.maxSrcSize)throw new s(`comp data ${e}b>maxSrcSize lim ${this.u.maxSrcSize}b)`);if(i||(i=(t=>{const i=t[4],s=i>>5&1,h=3&i,r=i>>6;return((t,i,s)=>{let h=0,r=0;for(;s>h;++h)r|=t[i++]<<(h<<3);return r})(t,6-s+h==3?4:h,r?1<<r:s)+(1==r&&256)})(t)),!i||i>h||e>r)return this.decompressStream(t,!0).buf;this.o.set(t,this.S),this.i.prune_buf(this.A);const n=this.A,o=this.i.decompressSync(n,this.M,this.S,e,this.p);if(0>o)throw new s("decomp err "+o);return this.o.slice(n,n+o)}D(t,i,s){const h=t>>>2;this.m[h]=i,this.m[h+1]=s,this.m[h+2]=0}v(t){return this.m[t+8>>>2]}decompressStream(i,h=!1){if(!this.i)throw new s("not initialized");if(h&&(this.i.reset(),this.p&&this.i.refDict(this.p),this.i.prune_buf(this.A)),!i||0===i.length)return e;const r=[];let n=0,o=0;const c=this.S+262150;let a=c,m=c+655360,u=0;for(;i.length>o;){const t=Math.min(Math.min(i.length-o,131075),262150);for(this.o.set(i.subarray(o,o+t),this.S),this.D(this._,this.S,t),a==c&&this.D(this.l,a,917501);this.v(this._)<t;){const t=this.i.decStream();if(0>t)throw new s("decomp err "+t);const i=this.v(this.l);if(n+=a==c?i:i-u,u=i,i>0&&(a=c+i,m>a||(r.push(this.o.slice(c,a)),a=c,this.D(this.l,a,917501)),n>this.u.maxDstSize))throw new s(`decomp size ${n}b>maxDstSize lim ${this.u.maxDstSize}b`)}o+=t}return a!=c&&r.push(this.o.slice(c,a)),{buf:t(r,n),in_offset:i.length}}destroy(){this.p=this.S=this.A=this._=this.l=this.t=this.i=this.h=this.o=this.m=null}}i=n;export{i as default,r as _MAX_SRC_BUF,n as ZstdDecoder};